---
title: "Process model results to generate results in article"
author: "Amy Heather"
---

This script assumes you have already run the scenarios in `models/` and saved those results to `.csv` files which we here then process to generate the results from the paper.

## Set-up

```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
```

```{r}
# Path to output folder
outputs = "../output"

# Paths to output files
files <- list(
  y65_s1_1k ="output_65yo_scen1_1k.csv",
  y65_s1_10k = "output_65yo_scen1_10k.csv",
  y65_s1_100k = "output_65yo_scen1_100k.csv",
  y65_s1_1m = "output_65yo_scen1_1mil.csv",
  y65_s1_2m = "output_65yo_scen1_2mil.csv",
  y65_s2 = "output_65yo_scen2.csv",
  surv_s0 = "output_surv_scen0.csv",
  surv_s1 = "output_surv_scen1.csv",
  surv_s2 = "output_surv_scen2.csv",
  tab2 = "tab2.csv",
  tab3 = "tab3.csv",
  fig1 = "fig1.png",
  fig2 = "fig2.png",
  fig3 = "fig3.png",
  fig4 = "fig4.png",
  fig5 = "fig5.png"
)

# Apply file.path to each element in list to create path to file in outputs
paths <- lapply(files, function(filename) file.path(outputs, filename))
```

```{r}
# Import files

y65_s1_1k <- read.csv(paths$y65_s1_1k)
y65_s1_10k <- read.csv(paths$y65_s1_10k)
y65_s1_100k <- read.csv(paths$y65_s1_100k)
y65_s1_1m <- read.csv(paths$y65_s1_1m)
y65_s1_2m <- read.csv(paths$y65_s1_2m)
y65_s2 <- read.csv(paths$y65_s2)

surv_s0 <- read.csv(paths$surv_s0)
surv_s1 <- read.csv(paths$surv_s1)
surv_s2 <- read.csv(paths$surv_s2)
```

## Functions

```{r}
make_tab <- function(df,
                     scale_to,
                     n_person=1000000,
                     groupvar="delayscr",
                     decreasing=FALSE) {
  #' Create section of tables from the article
  #' 
  #' Create table with a count of excess deaths and excess emergency operations
  #' with increasing delays in the simulation.
  #' 
  #' @param df Dataframe - results from the model
  #' @param scale_to Integer - number of expected people in actual population,
  #' which we scale our results to (so it reflects the number of outcomes
  #' anticipated in a population of that size)
  #' @param n_person Integer - number of people in the simulation model
  #' @param groupvar String - column with group names (i.e. colour in figure)
  #' @param decreasing Boolean - whether to sort group decreasing
  #' 
  #' @return tab2 Dataframe - excess deaths and emergency operations
  #' 
  #' @examples
  #' make_tab(y65_s1_1m, 1000000)

  # Sort dataframe by grouping variable (not using dplyr as it didn't work
  # when needed to parse the string column name with !!, and just did no sort)
  df_sort <- df[order(df[,groupvar], decreasing=decreasing),]
  rownames(df_sort) <- NULL

  # Remaining processing steps...
  tab2 <- df_sort %>%
    # Calculate the total number of emergency operations
    mutate(total_emer = emerevar + emeropen) %>%
    # Keep relevant columns
    select(!!groupvar, aaadead, total_emer) %>%
    # Scale to number of deaths if population size was as expected in real life
    mutate(scaled_dead = round(scale_to*(aaadead/n_person)),
           scaled_emer = round(scale_to*(total_emer/n_person))) %>%
    # Calculate excess (compare to time 0, but set negative to 0)
    mutate(excess_dead = pmax(scaled_dead - first(scaled_dead), 0),
           excess_emer = pmax(scaled_emer - first(scaled_emer), 0)) %>%
    # Combine (so its formatted like the article)
    mutate(excess_dead_emer = paste0(excess_dead, " (", excess_emer, ")")) %>%
    # Keep relevant columns
    select(!!groupvar, excess_dead_emer)

  return(tab2)
}


get_pct_change <- function(df, ordervar) {
  #' Get percentage change in the four outcomes (for use in figures)
  #' 
  #' @param df Dataframe with results from model
  #' @param ordervar String - column to order dataframe by (as percentage
  #' change will be against the first row in the dataframe)
  #' 
  #' @return fig_df Wide-format dataframe with percentage change added
  
  # Sort dataframe by ordering variable (not using dplyr as it didn't work
  # when needed to parse the string column name with !!, and just did no sort)
  df_sort <- df[order(df[,ordervar]),]
  rownames(df_sort) <- NULL

  fig_df <- df_sort %>%
    # Calculate the total number of emergency and elective operations
    mutate(total_emer = emerevar + emeropen,
           total_elec = elecevar + elecopen) %>%
    # Calculate percentage change from timepoint 0
    mutate(pct_dead = (aaadead - first(aaadead)) / first(aaadead) * 100,
           pct_elec = (total_elec - first(total_elec)) / first(total_elec) * 100,
           pct_emer = (total_emer - first(total_emer)) / first(total_emer) * 100,
           pct_rupt = (rupt - first(rupt)) / first(rupt) * 100) %>%

  return (fig_df)
}


prepare_fig_df <- function(df, pivotvar) {
  #' Prepares dataframe for use in making figure by melting and adding labels
  #' 
  #' @param df Dataframe with results calculated by get_pct_change(), filtered
  #' to just the relevant columns
  #' @param pivotvar String - name of column that serves as ID and that we keep
  #' as a column when melting the dataframe
  #' 
  #' @return fig_df_long Long-format dataframe ready for creating plots

  # Define labels
  fig_lab = list(pct_dead = "AAA deaths",
                 pct_elec = "Elective operations",
                 pct_emer = "Emergency operations",
                 pct_rupt = "Ruptures")

  # Melt dataframe from wide to long and add labels
  fig_df_long <- df %>%
    pivot_longer(-!!pivotvar) %>%
    mutate(label = recode(name, !!!fig_lab, .default = NA_character_))

  return (fig_df_long)
}


plot_fig <- function(df, xvar, xlab, savepath, xbreaks=NULL) {
  #' Plot the figure using ggplot2
  #' 
  #' @param df Dataframe created using prepare_fig_df()
  #' @param xvar String - column with data to plot along x axis
  #' @param xlab String - label for x axis
  #' @param savepath String - file path to save image
  #' @param xbreaks Numeric vector of positions for xbreaks, or NULL (which
  #' makes it keep the default xbreaks)

  p <- ggplot(df, aes(x=!!sym(xvar), y=value, color=label)) +
    geom_line() +
    geom_point() +
    labs(x=xlab,
         y="Percentage change in outcome",
         color="Outcome") +
    scale_y_continuous(limits = c(-10, 10),
                       breaks = seq(-10, 10, 2)) +
    {if(hasArg(xbreaks))scale_x_continuous(breaks = xbreaks)} +
    geom_hline(yintercept=0) +
    theme_bw()

  # Display plot
  print(p)

  # Save plot
  ggsave(savepath, width=7, height=5)
}
```

## Table 2

```{r}
tab2_delay <- make_tab(y65_s1_1m, scale_to=279798) %>%
  # Keep subset of results
  filter(delayscr %in% c(0.5, 1, 2, 3, 4, 5)) %>%
  # Convert time from years to months
  mutate(months = paste0(delayscr*12, "m")) %>%
  # Keep relevant columns
  select(months, excess_dead_emer)

tab2_delay
```

```{r}
# Just keep rows in scenario 2 where they had a 6 month delay
y65_s2_delay <- y65_s2 %>% filter(delayscr==0.5)

# Generate section of table 2
tab2_attend <- make_tab(y65_s2_delay, scale_to=279798,
                         groupvar="attend", decreasing=TRUE) %>%
  # Don't keep base result
  filter(attend != 0.75) %>%
  # Convert proportions to percentage
  mutate(perc = paste0(attend*100, "%")) %>%
  # Keep relevant columns
  select(perc, excess_dead_emer)

tab2_attend
```

Combine the delay and attend sections to produce table 2

```{r}
# Add empty rows to attendance and rename the results column to be distinct
tab2_attend_fill <- rbind(tab2_attend, tab2_attend[0,][rep(NA, 3),]) %>%
  rename(excess_dead_emer_attend = excess_dead_emer)

# Combine into single dataframe
tab2 <- cbind(tab2_delay, tab2_attend_fill )%>%
  # Rename columns to be similar to paper
  rename("Length of delay to invitation" = months,
         "Excess AAA deaths (excess emergency operations) in Model I1*" = excess_dead_emer,
         "Attendance rate at primary scan" = perc,
         "Excess AAA deaths (excess emergency operations) in Model I2*" = excess_dead_emer_attend)

# Reset index
rownames(tab2) <- NULL

# Save to csv
write.csv(tab2,paths$tab2, row.names=FALSE)

tab2
```

## Varying the number of people in the simulation for scenario 1

1000 people

```{r}
res1k <- make_tab(y65_s1_1k, scale_to=279798, n_person=1000) %>%
  # Keep subset of results
  filter(delayscr %in% c(0.5, 1, 2, 3, 4, 5)) %>%
  # Convert time from years to months
  mutate(months = paste0(delayscr*12, "m")) %>%
  # Keep relevant columns
  select(months, excess_dead_emer)

write.csv(res1k, "../../logbook/posts/2024_07_30/65y_s1_tab2_1k.csv", row.names=FALSE)

res1k
```

10,000 people

```{r}
res10k <- make_tab(y65_s1_10k, scale_to=279798, n_person=10000) %>%
  # Keep subset of results
  filter(delayscr %in% c(0.5, 1, 2, 3, 4, 5)) %>%
  # Convert time from years to months
  mutate(months = paste0(delayscr*12, "m")) %>%
  # Keep relevant columns
  select(months, excess_dead_emer)

write.csv(res10k, "../../logbook/posts/2024_07_30/65y_s1_tab2_10k.csv", row.names=FALSE)

res10k
```

100,000 people

```{r}
res100k <- make_tab(y65_s1_100k, scale_to=279798, n_person=100000) %>%
  # Keep subset of results
  filter(delayscr %in% c(0.5, 1, 2, 3, 4, 5)) %>%
  # Convert time from years to months
  mutate(months = paste0(delayscr*12, "m")) %>%
  # Keep relevant columns
  select(months, excess_dead_emer)

write.csv(res100k, "../../logbook/posts/2024_07_30/65y_s1_tab2_100k.csv", row.names=FALSE)

res100k
```

1,000,000 people

```{r}
res1m <- make_tab(y65_s1_1m, scale_to=279798, n_person=1000000) %>%
  # Keep subset of results
  filter(delayscr %in% c(0.5, 1, 2, 3, 4, 5)) %>%
  # Convert time from years to months
  mutate(months = paste0(delayscr*12, "m")) %>%
  # Keep relevant columns
  select(months, excess_dead_emer)

write.csv(res1m, "../../logbook/posts/2024_07_30/65y_s1_tab2_1m.csv", row.names=FALSE)

res1m
```

2,000,000 people

```{r}
res2m <- make_tab(y65_s1_2m, scale_to=279798, n_person=2000000) %>%
  # Keep subset of results
  filter(delayscr %in% c(0.5, 1, 2, 3, 4, 5)) %>%
  # Convert time from years to months
  mutate(months = paste0(delayscr*12, "m")) %>%
  # Keep relevant columns
  select(months, excess_dead_emer)

write.csv(res2m, "../../logbook/posts/2024_07_30/65y_s1_tab2_2m.csv", row.names=FALSE)

res2m
```

## Table 3

```{r}
# Define columns to keep (as don't all have same columns, so just filter to
# desired - and alternative would've been to filter to common cols)
cols = c("period", "elecevar", "elecopen", "emerevar", "emeropen",
         "aaadead", "rupt")

# Combine into single dataframe
surv_s0_s1 <- rbind(
  surv_s1 %>% select(any_of(cols)),
  surv_s0 %>% mutate(period=0) %>% select(any_of(cols)))

surv_s0_s1
```

```{r}
tab3_s1 <- make_tab(surv_s0_s1, scale_to = 15376, groupvar = "period") %>%
  # Keep subset of results
  filter(period %in% c(0.5, 1, 2, 3, 4, 5)) %>%
  # Convert time from years to months
  mutate(months = paste0(period*12, "m")) %>%
  # Keep relevant columns
  select(months, excess_dead_emer)

tab3_s1
```

## Figure 1

Process results from model into a dataframe to use for plotting.

```{r}
# Get percentage change
fig1_pct <- get_pct_change(df=y65_s1_1m, ordervar="delayscr") %>%
  # Keep relevant columns
  select(delayscr, starts_with("pct_"))

# Melt and label dataframe
fig1_df <- prepare_fig_df(fig1_pct, pivotvar="delayscr") %>%
  # Drop result from 0.25 months (not included in plot)
  filter(delayscr != 0.25)

# Create and save plot
plot_fig(fig1_df, xvar="delayscr", xlab="Delay in initial invitation (years)",
         savepath=paths$fig1)
```

## Figure 2

Here, the percentage change in outcome is compared against the outcome at 75% attendance with 0 months delay. Hence, we sort by delay (since that puts that row as first), but when we plot, we then remove that row, and just keep results with 6 months delay.

```{r}
# Calculate percentage change in four outcomes
fig2_pct <- get_pct_change(df=y65_s2, ordervar="delayscr") %>%
  # Drop result whith no delay
  filter(delayscr!=0) %>%
  # Keep relevant columns
  select(attend, starts_with("pct_")) %>%
  # Convert attendendance from proportion to percentage
  mutate(attend = attend*100)

# Melt and label dataframe
fig2_df <- prepare_fig_df(fig2_pct, pivotvar="attend")

# Create and save plot
plot_fig(fig2_df, xvar="attend", xlab="Attendance at initial scan (%)",
         xbreaks=seq(45, 75, 5), savepath=paths$fig2)
```

## Figure 3

```{r}
fig3_pct <- get_pct_change(df=surv_s0_s1, ordervar="period") %>%
  # Drop years 4 and 5
  filter(period <= 3) %>%
  # Keep relevant columns
  select(period, starts_with("pct_"))

# Melt and label dataframe
fig3_df <- prepare_fig_df(fig3_pct, pivotvar="period")

plot_fig(fig3_df, xvar="period", xlab="Surveillance scan suspension (years)",
         savepath=paths$fig3)
```
